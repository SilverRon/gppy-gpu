import re
from datetime import datetime
import os
from .logging import logger
import glob


def to_datetime_string(datetime_str, date_only=False):
    """Parse the input datetime string"""
    dt = datetime.fromisoformat(datetime_str.replace("Z", "+00:00"))

    # Format to desired output
    if date_only:
        return dt.strftime("%Y%m%d")
    else:
        return dt.strftime("%Y%m%d_%H%M%S")


def header_to_dict(file_path):
    """
    Parse a FITS header text file and convert it into a dictionary.

    This function reads a text file containing a FITS (Flexible Image Transport System)
    header generated by the `imhead` command, extracts key-value pairs from each line,
    and stores them in a dictionary.

    The function handles the following cases:
    - String values enclosed in single quotes are stripped of quotes and whitespace.
    - Numerical values are converted to integers or floats when possible.
    - Boolean values (`T` and `F` in FITS format) are converted to Python `True` and `False`.
    - Comments after the `/` character are ignored.

    Args:
        file_path (str): Path to the text file containing the FITS header.

    Returns:
        dict: A dictionary containing the parsed header, where keys are the FITS
        header keywords and values are the corresponding parsed values.

    Example:
        Given a FITS header file with the following lines:
            SIMPLE  = T / file does conform to FITS standard
            BITPIX  = 8 / number of bits per data pixel
            NAXIS   = 0 / number of data axes
            EXTEND  = T / FITS dataset may contain extensions

        The function will return:
        {
            "SIMPLE": True,
            "BITPIX": 8,
            "NAXIS": 0,
            "EXTEND": True
        }
    """
    # Regular expression to match FITS header format
    fits_pattern = re.compile(r"(\S+)\s*=\s*(.+?)(?:\s*/\s*(.*))?$")

    fits_dict = {}
    # Read the FITS header from the text file
    with open(file_path, "r", encoding="utf-8") as file:
        for line in file:
            match = fits_pattern.match(line)
            if match:
                key, value, comment = match.groups()
                value = value.strip()

                # Handle string values enclosed in single quotes
                if value.startswith("'") and value.endswith("'"):
                    value = value.strip("'").strip()

                # Convert numerical values
                else:
                    try:
                        if "." in value:
                            value = float(
                                value
                            )  # Convert to float if it contains a decimal
                        else:
                            value = int(value)  # Convert to integer otherwise
                    except ValueError:
                        pass  # Leave as string if conversion fails

                # Convert boolean values (T/F in FITS format)
                if value == "T":
                    value = True
                elif value == "F":
                    value = False

                fits_dict[key] = value

    return fits_dict


def get_camera(header):
    """Get camera type from image size.
    input is either path to .head file or header dict"""
    if type(header) == dict:
        pass
    else:
        header = header_to_dict(header)

    if header["NAXIS1"] == 9576:  # NAXIS2 6388
        return "C3"
    elif header["NAXIS1"] == 14208:  # NAXIS2 10656
        return "C5"
    else:
        return "Unidentified"


def query_sex_config(folder_path, process):
    postpix = ["sex", "params", "conv", "nnw"]
    return [os.path.join(folder_path, f"{process}.{pp}") for pp in postpix]


def find_raw_path(unit, date, n_binning, gain):
    from .const import RAWDATA_DIR

    raw_data_folder = glob.glob(f"{RAWDATA_DIR}/{unit}/{date}*")

    if len(raw_data_folder) > 1:
        raw_data_folder = glob.glob(f"{RAWDATA_DIR}/{unit}/{date}*_gain{gain}*")
        if len(raw_data_folder) > 1:
            raw_data_folder = glob.glob(
                f"{RAWDATA_DIR}/{unit}/{date}_{n_binning}x{n_binning}_gain{gain}*"
            )

    elif len(raw_data_folder) == 0:
        logger.error("No data folder found")

    return raw_data_folder[0]

def parse_exptime(filename, return_type="float"):
    exptime = float(re.search(r"_(\d+\.\d+)s_", filename).group(1))
    if return_type == int:
        return int(exptime)
    else:
        return exptime

def define_output_dir(date, n_binning, gain):
    return f"{date}_{n_binning}x{n_binning}_gain{gain}"


def lapse(explanation="elapsed", print_output=True):
    """
    A utility function to measure and report elapsed time using a global checkpoint.

    Parameters:
    explanation (str): Description for the elapsed time report. The form is "1 seconds {explanation}".

    Usage:
    lapse("Start")  # Initializes the timer and prints "Timer started"
    # Do something
    lapse("Task completed")  # Prints the time elapsed since the last call
    """
    from timeit import default_timer as timer

    global _dhutil_lapse_checkpoint  # Global Checkpoint

    current_time = timer()

    if _dhutil_lapse_checkpoint is None:  # Initialize if it's the first call
        _dhutil_lapse_checkpoint = current_time
    else:
        elapsed_time = current_time - _dhutil_lapse_checkpoint

        if elapsed_time < 60:
            dt, unit = elapsed_time, "seconds"
        elif elapsed_time > 3600:
            dt, unit = elapsed_time / 3600, "hours"
        else:
            dt, unit = elapsed_time / 60, "minutes"

        _dhutil_lapse_checkpoint = current_time  # Update the checkpoint

        print_str = f"{dt:.3f} {unit} {explanation}"
        logger.info(print_str)  # log the elapsed time at INFO level

        ####### This is for testing. Remove this line for production  #####
        if print_output:
            print(print_str, end="\n")  # log the elapsed time
        ###################################################################
        return elapsed_time  # in seconds
